"""
API endpoints –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–æ—Ñ–∏–ª–µ–π –¥–æ–ª–∂–Ω–æ—Å—Ç–µ–π.

–†–µ–∞–ª–∏–∑—É–µ—Ç —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω async task processing:
1. POST /api/generation/start - –∑–∞–ø—É—Å–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç task_id)
2. GET /api/generation/{task_id}/status - –ø–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–¥–∞—á–∏
3. GET /api/generation/{task_id}/result - –ø–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
4. DELETE /api/generation/{task_id} - –æ—Ç–º–µ–Ω–∞ –∑–∞–¥–∞—á–∏
"""

import uuid
import logging
import json
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List
from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends
from pydantic import BaseModel, Field

from ..core.config import config
from ..core.profile_generator import ProfileGenerator
from .auth import get_current_user
from ..models.database import db_manager

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/generation", tags=["generation"])


# Pydantic –º–æ–¥–µ–ª–∏
class GenerationRequest(BaseModel):
    department: str = Field(..., description="–ù–∞–∑–≤–∞–Ω–∏–µ –¥–µ–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç–∞")
    position: str = Field(..., description="–ù–∞–∑–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ—Å—Ç–∏")
    employee_name: Optional[str] = Field(
        None, description="–§–ò–û —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)"
    )
    temperature: float = Field(
        0.1, ge=0.0, le=1.0, description="–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ LLM"
    )
    save_result: bool = Field(True, description="–°–æ—Ö—Ä–∞–Ω—è—Ç—å –ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ —Ñ–∞–π–ª")


class GenerationTask(BaseModel):
    task_id: str
    status: str  # "queued", "processing", "completed", "failed", "cancelled"
    progress: Optional[int] = Field(None, description="–ü—Ä–æ–≥—Ä–µ—Å—Å –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö (0-100)")
    created_at: datetime
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    estimated_duration: Optional[int] = Field(
        None, description="–û—Ü–µ–Ω–æ—á–Ω–æ–µ –≤—Ä–µ–º—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö"
    )
    current_step: Optional[str] = Field(None, description="–¢–µ–∫—É—â–∏–π —ç—Ç–∞–ø –æ–±—Ä–∞–±–æ—Ç–∫–∏")
    error_message: Optional[str] = None


class GenerationResponse(BaseModel):
    task_id: str
    status: str
    message: str
    estimated_duration: Optional[int] = None


class TaskStatusResponse(BaseModel):
    task: GenerationTask
    result: Optional[Dict[str, Any]] = None


# In-memory storage –¥–ª—è –∑–∞–¥–∞—á (–≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Redis)
_active_tasks: Dict[str, Dict[str, Any]] = {}
_task_results: Dict[str, Dict[str, Any]] = {}


async def get_profile_generator() -> ProfileGenerator:
    """Dependency –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è ProfileGenerator —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏"""
    if not config.openrouter_configured:
        raise HTTPException(
            status_code=503,
            detail="OpenRouter API –Ω–µ —Å–∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–æ–≤–∞–Ω. –î–æ–±–∞–≤—å—Ç–µ OPENROUTER_API_KEY –≤ .env",
        )

    # ProfileGenerator —Ç–µ–ø–µ—Ä—å —Å–∞–º –ø–æ–ª—É—á–∞–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ config
    generator = ProfileGenerator()

    return generator


async def background_generate_profile(
    task_id: str, request: GenerationRequest, user_id: int
):
    """Background task –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è"""

    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞ "processing"
    _active_tasks[task_id].update(
        {
            "status": "processing",
            "started_at": datetime.now(),
            "current_step": "–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –ø—Ä–æ—Ñ–∏–ª–µ–π",
            "progress": 5,
        }
    )

    try:
        # –ü–æ–ª—É—á–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
        generator = await get_profile_generator()

        # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
        _active_tasks[task_id].update(
            {"current_step": "–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∫–æ–º–ø–∞–Ω–∏–∏", "progress": 15}
        )

        # –í–∞–ª–∏–¥–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã
        validation_result = await generator.validate_system()
        if not validation_result["system_ready"]:
            raise Exception(f"–°–∏—Å—Ç–µ–º–∞ –Ω–µ –≥–æ—Ç–æ–≤–∞: {validation_result['errors']}")

        _active_tasks[task_id].update(
            {"current_step": "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ—Ñ–∏–ª—è —á–µ—Ä–µ–∑ LLM", "progress": 30}
        )

        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ—Ñ–∏–ª—è
        result = await generator.generate_profile(
            department=request.department,
            position=request.position,
            employee_name=request.employee_name,
            temperature=request.temperature,
            save_result=request.save_result,
        )

        _active_tasks[task_id].update(
            {"current_step": "–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞", "progress": 90}
        )

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
        if result["success"]:
            await save_generation_to_db(result, user_id, task_id)

        # –ó–∞–≤–µ—Ä—à–∞–µ–º –∑–∞–¥–∞—á—É
        _active_tasks[task_id].update(
            {
                "status": "completed" if result["success"] else "failed",
                "completed_at": datetime.now(),
                "current_step": "–ó–∞–≤–µ—Ä—à–µ–Ω–æ",
                "progress": 100,
                "error_message": (
                    "; ".join(result.get("errors", []))
                    if not result["success"]
                    else None
                ),
            }
        )

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        _task_results[task_id] = result

        logger.info(f"‚úÖ Generation task {task_id} completed successfully")

    except Exception as e:
        logger.error(f"‚ùå Generation task {task_id} failed: {e}")

        _active_tasks[task_id].update(
            {
                "status": "failed",
                "completed_at": datetime.now(),
                "current_step": "–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏",
                "progress": 0,
                "error_message": str(e),
            }
        )


async def save_generation_to_db(result: Dict[str, Any], user_id: int, task_id: str):
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
    try:
        conn = db_manager.get_connection()
        cursor = conn.cursor()

        # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è –ø—Ä–æ—Ñ–∏–ª—è
        profile_id = str(uuid.uuid4())

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å—Ö–µ–º–æ–π
        cursor.execute(
            """
            INSERT INTO profiles (
                id, department, position, employee_name,
                profile_data, metadata_json,
                generation_duration_ms, tokens_used, langfuse_trace_id,
                created_by, created_at, updated_at, generation_task_id
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """,
            (
                profile_id,
                result["metadata"]["generation"]["department"],
                result["metadata"]["generation"]["position"],
                result["metadata"]["generation"].get("employee_name"),
                json.dumps(result["profile"], ensure_ascii=False),
                json.dumps(result["metadata"], ensure_ascii=False),
                int(result["metadata"]["generation"]["duration"] * 1000),
                result["metadata"]["llm"].get("tokens_used", 0),
                result["metadata"].get("langfuse_trace_id"),
                user_id,
                datetime.now().isoformat(),
                datetime.now().isoformat(),
                task_id,
            ),
        )

        conn.commit()
        conn.close()

        logger.info(f"üíæ Saved generation result to database: profile_id={profile_id}")

    except Exception as e:
        logger.error(f"‚ùå Failed to save generation to DB: {e}")


@router.post("/start", response_model=GenerationResponse)
async def start_generation(
    request: GenerationRequest,
    background_tasks: BackgroundTasks,
    current_user=Depends(get_current_user),
):
    """
    –ó–∞–ø—É—Å–∫ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è –¥–æ–ª–∂–Ω–æ—Å—Ç–∏

    Returns:
        task_id –∏ –ø—Ä–∏–º–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    """
    # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –∑–∞–¥–∞—á–∏
    task_id = str(uuid.uuid4())

    # –û—Ü–µ–Ω–æ—á–Ω–æ–µ –≤—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (30-60 —Å–µ–∫—É–Ω–¥)
    estimated_duration = 45

    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∑–∞–¥–∞—á—É
    _active_tasks[task_id] = {
        "task_id": task_id,
        "status": "queued",
        "progress": 0,
        "created_at": datetime.now(),
        "started_at": None,
        "completed_at": None,
        "estimated_duration": estimated_duration,
        "current_step": "–í –æ—á–µ—Ä–µ–¥–∏ –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É",
        "request": request.dict(),
        "user_id": current_user["user_id"],
    }

    # –ó–∞–ø—É—Å–∫–∞–µ–º background task
    background_tasks.add_task(
        background_generate_profile, task_id, request, current_user["user_id"]
    )

    logger.info(
        f"üöÄ Started generation task {task_id} for user {current_user['username']}"
    )

    return GenerationResponse(
        task_id=task_id,
        status="queued",
        message=f"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ—Ñ–∏–ª—è '{request.position}' –≤ '{request.department}' –∑–∞–ø—É—â–µ–Ω–∞",
        estimated_duration=estimated_duration,
    )


@router.get("/{task_id}/status", response_model=TaskStatusResponse)
async def get_task_status(task_id: str, current_user=Depends(get_current_user)):
    """
    –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–¥–∞—á–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏

    Args:
        task_id: ID –∑–∞–¥–∞—á–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏

    Returns:
        –¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
    """
    if task_id not in _active_tasks:
        raise HTTPException(status_code=404, detail="–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

    task_data = _active_tasks[task_id]

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
    if task_data["user_id"] != current_user["user_id"]:
        raise HTTPException(status_code=403, detail="–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∑–∞–¥–∞—á–µ")

    # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
    task = GenerationTask(**task_data)
    result = _task_results.get(task_id) if task.status == "completed" else None

    return TaskStatusResponse(task=task, result=result)


@router.get("/{task_id}/result")
async def get_task_result(task_id: str, current_user=Depends(get_current_user)):
    """
    –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è

    Args:
        task_id: ID –∑–∞–¥–∞—á–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏

    Returns:
        –ü–æ–ª–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è
    """
    if task_id not in _active_tasks:
        raise HTTPException(status_code=404, detail="–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

    task_data = _active_tasks[task_id]

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
    if task_data["user_id"] != current_user["user_id"]:
        raise HTTPException(status_code=403, detail="–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∑–∞–¥–∞—á–µ")

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏
    if task_data["status"] not in ["completed", "failed"]:
        raise HTTPException(
            status_code=202,
            detail=f"–ó–∞–¥–∞—á–∞ –µ—â–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è. –°—Ç–∞—Ç—É—Å: {task_data['status']}",
        )

    if task_id not in _task_results:
        raise HTTPException(status_code=404, detail="–†–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")

    return _task_results[task_id]


@router.delete("/{task_id}")
async def cancel_task(task_id: str, current_user=Depends(get_current_user)):
    """
    –û—Ç–º–µ–Ω–∞ –∑–∞–¥–∞—á–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (–µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ)

    Args:
        task_id: ID –∑–∞–¥–∞—á–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    """
    if task_id not in _active_tasks:
        raise HTTPException(status_code=404, detail="–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

    task_data = _active_tasks[task_id]

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
    if task_data["user_id"] != current_user["user_id"]:
        raise HTTPException(status_code=403, detail="–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∑–∞–¥–∞—á–µ")

    # –û—Ç–º–µ–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∑–∞–¥–∞—á–∞ –µ—â–µ –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
    if task_data["status"] in ["queued", "processing"]:
        _active_tasks[task_id].update(
            {
                "status": "cancelled",
                "completed_at": datetime.now(),
                "current_step": "–û—Ç–º–µ–Ω–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º",
                "error_message": "–ó–∞–¥–∞—á–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º",
            }
        )

        logger.info(f"üõë Cancelled generation task {task_id}")

        return {"message": "–ó–∞–¥–∞—á–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞"}
    else:
        raise HTTPException(
            status_code=400,
            detail=f"–ù–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å –∑–∞–¥–∞—á—É –≤ —Å—Ç–∞—Ç—É—Å–µ: {task_data['status']}",
        )


@router.get("/tasks/active")
async def get_active_tasks(
    current_user=Depends(get_current_user),
) -> List[GenerationTask]:
    """
    –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

    Returns:
        –°–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    user_tasks = []

    for task_data in _active_tasks.values():
        if task_data["user_id"] == current_user["user_id"]:
            # –ò—Å–∫–ª—é—á–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ —Å—Ç–∞—Ä—à–µ 1 —á–∞—Å–∞
            if task_data["status"] in ["completed", "failed", "cancelled"]:
                completed_at = task_data.get("completed_at")
                if completed_at and datetime.now() - completed_at > timedelta(hours=1):
                    continue

            user_tasks.append(GenerationTask(**task_data))

    return user_tasks


@router.post("/cleanup")
async def cleanup_old_tasks(current_user=Depends(get_current_user)):
    """
    –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á (—Ç–æ–ª—å–∫–æ admin)
    """
    if current_user["username"] != "admin":
        raise HTTPException(status_code=403, detail="–¢–æ–ª—å–∫–æ admin –º–æ–∂–µ—Ç –æ—á–∏—â–∞—Ç—å –∑–∞–¥–∞—á–∏")

    cleanup_count = 0
    cutoff_time = datetime.now() - timedelta(hours=24)

    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–¥–∞—á–∏
    tasks_to_remove = []
    for task_id, task_data in _active_tasks.items():
        if task_data["status"] in ["completed", "failed", "cancelled"]:
            completed_at = task_data.get("completed_at")
            if completed_at and completed_at < cutoff_time:
                tasks_to_remove.append(task_id)

    for task_id in tasks_to_remove:
        del _active_tasks[task_id]
        if task_id in _task_results:
            del _task_results[task_id]
        cleanup_count += 1

    logger.info(f"üßπ Cleaned up {cleanup_count} old tasks")

    return {
        "message": f"–û—á–∏—â–µ–Ω–æ {cleanup_count} —Å—Ç–∞—Ä—ã—Ö –∑–∞–¥–∞—á",
        "active_tasks": len(_active_tasks),
    }


def initialize_generation_system():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ"""
    logger.info("üßπ Initializing generation system...")
    _active_tasks.clear()
    _task_results.clear()
    logger.info("‚úÖ Generation system initialized")
